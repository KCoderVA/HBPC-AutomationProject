name: CI Audit
on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  audit:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up git for automated commit
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
      - name: Validate fieldSchema.json
        shell: pwsh
        run: |
          $schemaPath = 'config/fieldSchema.json'
          $schemaSpec = 'config/fieldSchema.schema.json'
          if(!(Test-Path $schemaPath)){ Write-Error 'fieldSchema.json missing'; exit 1 }
          $json = Get-Content $schemaPath -Raw | ConvertFrom-Json
          if(-not $json.fields){ Write-Error 'No fields array found'; exit 1 }
          if(Test-Path $schemaSpec){
            # Basic schema structural validation (manual due to no external lib):
            $raw = Get-Content $schemaPath -Raw | ConvertFrom-Json
            foreach($f in $raw.fields){
              foreach($req in 'internalName','displayLabel','dataType','fallback'){
                if([string]::IsNullOrWhiteSpace($f.$req)){ Write-Error "Schema violation: missing $req on a field" }
              }
              if($f.sensitivity -and $f.sensitivity -notin @('Low','Moderate','High')){ Write-Error "Invalid sensitivity $($f.sensitivity)" }
            }
          }
          $invalid = @()
          foreach($f in $json.fields){
            if([string]::IsNullOrWhiteSpace($f.internalName)){ $invalid += 'missing internalName' }
            if([string]::IsNullOrWhiteSpace($f.fallback)){ $invalid += "$($f.internalName): missing fallback" }
            if($f.choice -and -not $f.requiresValueSuffix){ $invalid += "$($f.internalName): choice without requiresValueSuffix" }
          }
          # Duplicate internalName detection
          $dupes = $json.fields | Group-Object internalName | Where-Object { $_.Count -gt 1 } | ForEach-Object { $_.Name }
          if($dupes){ $invalid += ('Duplicate internalName(s): ' + ($dupes -join ', ')) }
          if($invalid.Count -gt 0){ Write-Error ("Schema validation errors:`n" + ($invalid -join "`n")); exit 1 }
          Write-Host 'fieldSchema.json validation OK'
      - name: Auto-update README badge schema field count
        shell: pwsh
        run: |
          $schemaPath = 'config/fieldSchema.json'
          $readmePath = 'README.md'
          if(!(Test-Path $schemaPath)){ Write-Error 'Schema file missing for badge update'; exit 1 }
          if(!(Test-Path $readmePath)){ Write-Error 'README.md missing'; exit 1 }
          $schemaJson = Get-Content $schemaPath -Raw | ConvertFrom-Json
          if(-not $schemaJson.fields){ Write-Error 'fields array absent in schema'; exit 1 }
          $count = $schemaJson.fields.Count
          $readme = Get-Content $readmePath -Raw
          $markerPattern = '(?s)<!-- BADGES:START -->(.*?)<!-- BADGES:END -->'
          $m = [regex]::Match($readme, $markerPattern)
          if(-not $m.Success){ Write-Error 'Badge markers not found'; exit 1 }
          $block = $m.Value
          $countMatch = [regex]::Match($block, 'Schema Fields:\s*(\d+)')
          if(-not $countMatch.Success){ Write-Error 'Schema Fields count token missing in badge block'; exit 1 }
          $existing = [int]$countMatch.Groups[1].Value
          if($existing -eq $count){ Write-Host "Badge already up-to-date ($count)."; exit 0 }
          $newBlock = $block -replace 'Schema Fields:\s*\d+', "Schema Fields: $count"
          $updated = $readme.Substring(0,$m.Index) + $newBlock + $readme.Substring($m.Index + $m.Length)
          Set-Content -Path $readmePath -Value $updated -Encoding UTF8
          git add $readmePath
          git commit -m "chore(readme): update schema fields badge to $count" || echo 'No changes to commit'
      - name: Badge SVG presence warning
        shell: pwsh
        run: |
          $badgePath = 'assets/badges/schema-field-count.svg'
          if(Test-Path $badgePath){ Write-Host "Badge SVG present at $badgePath" } else { Write-Warning "Badge SVG missing at $badgePath (will regenerate on release tag)" }
      - name: Update build info block
        shell: pwsh
        run: |
          $readmePath = 'README.md'
          if(!(Test-Path $readmePath)){ Write-Error 'README.md missing'; exit 1 }
          $content = Get-Content $readmePath -Raw
          if($content -notmatch '<!-- BUILDINFO:START -->'){ Write-Error 'Build info markers missing'; exit 1 }
          $shortSha = (git rev-parse --short HEAD).Trim()
          $utcDate = (Get-Date).ToUniversalTime().ToString('yyyy-MM-dd')
          $schemaPath = 'config/fieldSchema.json'
          $schemaCount = if(Test-Path $schemaPath){ (Get-Content $schemaPath -Raw | ConvertFrom-Json).fields.Count } else { 0 }
          # Determine last semantic tag
          $lastTag = (git tag --list 'v*' --sort=-creatordate | Select-Object -First 1)
          if([string]::IsNullOrWhiteSpace($lastTag)){ $lastTag = 'none' }
          if($lastTag -eq 'none'){
            $commitsSince = (git rev-list --count HEAD)
            # Files since 'none' treated as total tracked files for initial baseline
            $filesSince = (git ls-files | Measure-Object | ForEach-Object { $_.Count })
          } else {
            $commitsSince = (git rev-list --count "$lastTag..HEAD")
            $filesSince = (git diff --name-only $lastTag HEAD | Measure-Object | ForEach-Object { $_.Count })
          }
          if(-not $filesSince){ $filesSince = 0 }
          $newBlock = "<!-- BUILDINFO:START --><div><em>Build Info</em>: Commit <code>$shortSha</code> • UTC <code>$utcDate</code> • Last Tag <code>$lastTag</code> • Commits Since Tag <code>$commitsSince</code> • Files Since Tag <code>$filesSince</code> • Schema Fields Snapshot <code>$schemaCount</code></div><!-- BUILDINFO:END -->"
          $updated = [regex]::Replace($content,'<!-- BUILDINFO:START -->.*?<!-- BUILDINFO:END -->',$newBlock,'Singleline')
          if($updated -ne $content){ Set-Content -Path $readmePath -Value $updated -Encoding UTF8; git add $readmePath; git commit -m "chore(readme): refresh build info ($shortSha)" | Out-Null } else { Write-Host 'Build info already current' }
      - name: Update README Status date
        shell: pwsh
        run: |
          $path = 'README.md'
          if(!(Test-Path $path)){ exit 0 }
          $raw = Get-Content $path -Raw
          $today = (Get-Date).ToUniversalTime().ToString('yyyy-MM-dd')
          if($raw -match 'EOD \d{4}-\d{2}-\d{2}'){
            $new = [regex]::Replace($raw,'EOD \d{4}-\d{2}-\d{2}','EOD '+$today)
            if($new -ne $raw){ Set-Content $path -Value $new -Encoding UTF8; git add $path; git commit -m "chore(readme): update status date $today" | Out-Null }
          }
      - name: Generate build-manifest.json
        shell: pwsh
        run: |
          $schemaPath = 'config/fieldSchema.json'
          $schemaCount = if(Test-Path $schemaPath){ (Get-Content $schemaPath -Raw | ConvertFrom-Json).fields.Count } else { 0 }
          $shortSha = (git rev-parse --short HEAD).Trim()
          $lastTag = (git tag --list 'v*' --sort=-creatordate | Select-Object -First 1)
          if([string]::IsNullOrWhiteSpace($lastTag)){ $lastTag = 'none' }
          if($lastTag -eq 'none'){
            $commitsSince = (git rev-list --count HEAD)
            $filesSince = (git ls-files | Measure-Object | ForEach-Object { $_.Count })
          } else {
            $commitsSince = (git rev-list --count "$lastTag..HEAD")
            $filesSince = (git diff --name-only $lastTag HEAD | Measure-Object | ForEach-Object { $_.Count })
          }
          $manifest = [ordered]@{
            commit = $shortSha
            dateUtc = (Get-Date).ToUniversalTime().ToString('yyyy-MM-dd')
            lastTag = $lastTag
            commitsSinceTag = $commitsSince
            filesSinceTag = $filesSince
            schemaFieldCount = $schemaCount
          } | ConvertTo-Json -Depth 4
          if(!(Test-Path metrics)){ New-Item -ItemType Directory -Path metrics | Out-Null }
          Set-Content metrics/build-manifest.json -Value $manifest -Encoding UTF8
          git add metrics/build-manifest.json; git commit -m 'chore(metrics): update build-manifest snapshot' | Out-Null
      - name: Policy version bump if changed (governance relocation)
        shell: pwsh
        run: |
          $govPath = 'governance/GOVERNANCE.md'
          if(!(Test-Path $govPath)){ Write-Host 'GOVERNANCE.md missing'; exit 0 }
          $raw = Get-Content $govPath -Raw
          if($raw -notmatch '<!-- POLICY-VERSION:START -->'){ Write-Host 'Policy version markers absent'; exit 0 }
          $line = [regex]::Match($raw,'<!-- POLICY-VERSION:START -->.*?<!-- POLICY-VERSION:END -->').Value
          $versionMatch = [regex]::Match($line,'Policy Version: (\d+)(?: \(hash: ([0-9a-f]+)\))?')
          if(-not $versionMatch.Success){ Write-Host 'Policy version parse failed'; exit 0 }
          $currentVersion = [int]$versionMatch.Groups[1].Value
          $oldHash = $versionMatch.Groups[2].Value
          # Compute hash excluding marker block
          $contentSans = [regex]::Replace($raw,'<!-- POLICY-VERSION:START -->.*?<!-- POLICY-VERSION:END -->','')
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($contentSans)
          $sha256 = [System.BitConverter]::ToString((New-Object System.Security.Cryptography.SHA256Managed).ComputeHash($bytes)).Replace('-','').ToLower()
          if($sha256 -ne $oldHash){
            $newVersion = $currentVersion + 1
            $newMarker = "<!-- POLICY-VERSION:START -->Policy Version: $newVersion (hash: $sha256)<!-- POLICY-VERSION:END -->"
            $updated = [regex]::Replace($raw,'<!-- POLICY-VERSION:START -->.*?<!-- POLICY-VERSION:END -->',$newMarker)
            Set-Content $govPath -Value $updated -Encoding UTF8
            git add $govPath; git commit -m "chore(governance): bump policy version to $newVersion" | Out-Null
          } else { Write-Host 'Governance unchanged; version stays' }
      - name: Orphaned test artifact detection (non-fatal)
        shell: pwsh
        run: |
          $readme = Get-Content README.md -Raw
          $artifactLines = ($readme -split "`n") | Where-Object { $_ -match '^\| `.+` \| ' }
          $mentioned = @()
          foreach($l in $artifactLines){ $m = [regex]::Match($l,'`([^`]+)`'); if($m.Success){ $mentioned += $m.Groups[1].Value } }
          $testFiles = Get-ChildItem tests -Recurse -File | ForEach-Object { $_.Name }
          $orphans = $testFiles | Where-Object { $_ -notin $mentioned }
          if($orphans){ Write-Warning "Orphaned test artifacts not referenced in README: $($orphans -join ', ')" } else { Write-Host 'No orphaned test artifacts' }
      - name: Orphaned docs detection (non-fatal)
        shell: pwsh
        run: |
          $readme = Get-Content README.md -Raw
          $tableLines = ($readme -split "`n") | Where-Object { $_ -match '^\| `.+` \| ' }
          $mentioned = @()
          foreach($l in $tableLines){ foreach($m in ([regex]::Matches($l,'`([^`]+)`'))){ $mentioned += $m.Groups[1].Value } }
          $docFiles = Get-ChildItem docs -File -Filter *.md | ForEach-Object { $_.Name }
          $docFiles = $docFiles | Where-Object { $_ -ne 'DOC_INDEX.md' }
          $orphans = $docFiles | Where-Object { $_ -notin $mentioned }
          if($orphans){ Write-Warning "Docs not referenced in README artifact table: $($orphans -join ', ')" } else { Write-Host 'All docs referenced in README table' }
      - name: Artifact table path consistency (non-fatal)
        shell: pwsh
        run: |
          $readme = Get-Content README.md -Raw
          $issues = @()
          if($readme -notmatch '\`GOVERNANCE.md\` \| \`governance/') { $issues += 'GOVERNANCE.md row missing governance/ location formatting' }
          foreach($f in 'SECURITY.md','RELEASE.md','LABELS.md','CONTRIBUTING.md'){ if($readme -notmatch "`$f` \| `governance/") { $issues += "$f row missing governance/ location formatting" } }
          foreach($f in 'copilot-instructions.md'){ if($readme -notmatch "`$f` \| `.github/") { $issues += "$f row missing .github/ location formatting" } }
          foreach($f in 'copilot-quickref.md','HBPC_AdmitsDischarges.code-workspace'){ if($readme -notmatch "`$f` \| `dev/") { $issues += "$f row missing dev/ location formatting" } }
          if($issues.Count -gt 0){ Write-Warning ("Artifact table consistency issues:`n" + ($issues -join "`n")) } else { Write-Host 'Artifact table path consistency OK' }
      - name: Enforce CHANGELOG headings
        shell: pwsh
        run: |
          $cl = Get-Content CHANGELOG.md -Raw
          if($cl -match '## \[Unreleased\]([\s\S]*?)(## \[|$)'){
            $block = $Matches[1]
            $required = @('Added','Changed','Fixed')
            foreach($h in $required){ if($block -notmatch "### $h" ){ Write-Error "CHANGELOG missing '### $h' in Unreleased" } }
          } else { Write-Error 'Unreleased section parse failure' }
      - name: SECURITY.md section checks (governance relocation)
        shell: pwsh
        run: |
          $sec = Get-Content governance/SECURITY.md -Raw
          foreach($req in 'PHI Categories','Reporting Potential Exposure'){ if($sec -notmatch $req){ Write-Error "SECURITY.md missing section: $req" } }
      - name: PHI pattern scan
        shell: pwsh
        run: |
          $bad = @()
          $files = git ls-files | Where-Object { $_ -notlike 'tests/flowSuccess/*' -and $_ -notlike 'tests/flowFailure/*' }
          foreach($f in $files){
            $text = Get-Content $f -Raw
            # SSN
            $matches = [regex]::Matches($text,'\b(?!000-00-0000)(\d{3}-\d{2}-\d{4})\b')
            foreach($m in $matches){ if($text -notmatch '\*\*\*'){ $bad += "$f:SSN:$($m.Value)" } }
            # DOB: Only flag years 1900-2024
            $dobMatches = [regex]::Matches($text,'\b(19[0-9]{2}|20[0-1][0-9]|202[0-4])-[0-9]{2}-[0-9]{2}\b')
            foreach($d in $dobMatches){ $bad += "$f:DOB:$($d.Value)" }
            $dobMatches2 = [regex]::Matches($text,'\b[0-9]{2}/[0-9]{2}/(19[0-9]{2}|20[0-1][0-9]|202[0-4])\b')
            foreach($d in $dobMatches2){ $bad += "$f:DOB:$($d.Value)" }
          }
          if($bad){ Write-Error "Potential PHI patterns detected:`n$($bad -join "`n")" }
      - name: PHI masking heuristic (non-fatal)
        shell: pwsh
        run: |
          $warn = @()
          $files = git ls-files | Where-Object { $_ -notlike 'tests/flowSuccess/*' -and $_ -notlike 'tests/flowFailure/*' }
          $whitelistNames = @('Veteran Affairs','Health System','Admission Flow','Build Info','Power Automate','Saved Form')
          $whitelistPatterns = $whitelistNames | ForEach-Object { [regex]::Escape($_) }
          $joined = ($whitelistPatterns -join '|')
          foreach($f in $files){
            $text = Get-Content $f -Raw
            # Phone numbers (basic) not already masked (exclude patterns with X or *)
            $phones = [regex]::Matches($text,'\b\d{3}[ -]?\d{3}[ -]?\d{4}\b') | ForEach-Object { $_.Value } | Where-Object { $_ -notmatch '[Xx\*]{3}-?[Xx\*]{2}-?[Xx\*]{4}' }
            foreach($p in $phones){ $warn += "$f: phone?$p" }
            # Simple address heuristic: number + word + (Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd)
            $addr = [regex]::Matches($text,'\b\d{1,5}\s+[A-Z][a-zA-Z]+\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd)\b') | ForEach-Object { $_.Value }
            foreach($a in $addr){ if($joined -and $a -match $joined){ continue }; $warn += "$f: address?$a" }
            # Potential full names: First Last (Capitalization) not already generic (skip if 'Veteran' or whitelisted)
            $names = [regex]::Matches($text,'\b[A-Z][a-z]+\s+[A-Z][a-z]+\b') | ForEach-Object { $_.Value } | Where-Object { $_ -notmatch 'Veteran|Not Provided' }
            foreach($n in $names){ if($joined -and $n -match $joined){ continue }; $warn += "$f: name?$n" }
          }
          if($warn.Count -gt 0){ Write-Warning "Heuristic PHI candidates (filtered):`n$($warn -join "`n")" } else { Write-Host 'No heuristic PHI candidates after filtering' }
      - name: LICENSE hash verification
        shell: pwsh
        run: |
          $expected = 'APACHE-2.0'
          $lic = Get-Content LICENSE.txt -Raw
          if($lic -notmatch 'Apache License'){ Write-Error 'LICENSE missing Apache text' }
          # simple marker token only; canonical hash option can be added later
          Write-Host 'LICENSE text looks valid'
      - name: CODEOWNERS presence
        shell: pwsh
        run: |
          if(!(Test-Path CODEOWNERS)){ Write-Error 'CODEOWNERS missing' }
          if(-not (Get-Content CODEOWNERS | Where-Object { $_ -match '\S'})){ Write-Error 'CODEOWNERS empty' }
      - name: Conventional commit prefix (HEAD)
        shell: pwsh
        run: |
          $msg = git log -1 --pretty=%s
          if($msg -notmatch '^(feat|fix|chore|docs|refactor|security|perf|test|build|ci)(\(|:){1}'){ Write-Error "Head commit not conventional: $msg" }
      - name: SPDX header validation (scripts)
        shell: pwsh
        run: |
          $violations = @()
          Get-ChildItem scripts -Filter *.ps1 | ForEach-Object { $c = Get-Content $_.FullName -Raw; if($c -notmatch 'SPDX-License-Identifier'){ $violations += $_.Name } }
          if($violations){ Write-Error "Missing SPDX header: $($violations -join ', ')" }
      - name: Expression audit (Compose JSON)
        shell: pwsh
        run: |
          $path = 'tests/altered/altered_RawCodeView.json'
          if(!(Test-Path $path)){ Write-Host 'Compose JSON not found, skipping audit'; exit 0 }
          $raw = Get-Content $path -Raw
          $errors = @()
          $ifCount = ([regex]::Matches($raw,'@\{if\(empty\(')).Count
          if($ifCount -lt 10){ $errors += "Suspiciously low fallback pattern count ($ifCount)" }
          if($raw -match 'RECONSTRUCTED-MID-BLOCK-START'){
            $segment = [regex]::Match($raw,'RECONSTRUCTED-MID-BLOCK-START([\s\S]*?)RECONSTRUCTED-MID-BLOCK-END').Groups[1].Value
            if($segment -match 'coalesce\('){ $errors += 'Legacy coalesce() found in reconstructed segment' }
          }
          $openTokens = ([regex]::Matches($raw,'@\{')).Count
          $closeTokens = ([regex]::Matches($raw,'\}')).Count
            
          if($openTokens -gt $closeTokens){ $errors += "Unbalanced tokens: @{=$openTokens }=$closeTokens" }
          $invalidPatterns = 0
          foreach($m in [regex]::Matches($raw,'@\{if\(empty\((.*?)\)')){ if($m.Value -notmatch '\)\)'){ $invalidPatterns++ } }
          if($invalidPatterns -gt 0){ $errors += "Fallback patterns missing closing )) count=$invalidPatterns" }
          if($errors.Count -gt 0){ Write-Error ("Expression audit failures:`n" + ($errors -join "`n")) } else { Write-Host "Expression audit passed (if(empty) count=$ifCount)" }
      - name: Auto-sort schema fields
        shell: pwsh
        run: |
          $path = 'config/fieldSchema.json'
          $orig = Get-Content $path -Raw | ConvertFrom-Json
          $sorted = ($orig.fields | Sort-Object internalName)
          $needs = $false
          for($i=0;$i -lt $orig.fields.Count;$i++){ if($orig.fields[$i].internalName -ne $sorted[$i].internalName){ $needs = $true; break } }
          if($needs){
            $orig.fields = $sorted
            ($orig | ConvertTo-Json -Depth 6) | Set-Content $path -Encoding UTF8
            git add $path; git commit -m 'chore(schema): auto-sort fields' | Out-Null
          } else { Write-Host 'Schema already sorted' }
          # If build-manifest exists append build info reference slug to README build block
          if(Test-Path 'metrics/build-manifest.json'){
            $readmePath = 'README.md'
            if(Test-Path $readmePath){
              $content = Get-Content $readmePath -Raw
              if($content -match '<!-- BUILDINFO:START -->'){ 
                if($content -notmatch 'Metrics Manifest'){ 
                  $content = [regex]::Replace($content,'(<!-- BUILDINFO:START -->.*?</div>)',"$1".Replace('</div>',' • Metrics Manifest <code>metrics/build-manifest.json</code></div>'))
                  Set-Content $readmePath -Value $content -Encoding UTF8; git add $readmePath; git commit -m 'chore(readme): add metrics manifest reference' | Out-Null 
                }
              }
            }
          }
      - name: Schema summary table injection
        shell: pwsh
        run: |
          $mdPath = 'docs/FIELD_SCHEMA.md'
          if(!(Test-Path $mdPath)){ Write-Host 'FIELD_SCHEMA.md not present'; exit 0 }
          $json = Get-Content config/fieldSchema.json -Raw | ConvertFrom-Json
          $rows = foreach($f in $json.fields){ "| $($f.internalName) | $($f.displayLabel) | $($f.section) | $($f.category) | $($f.sensitivity) | $($f.dataType) |" }
          $table = @("<!-- SCHEMA-SUMMARY:START -->","| Internal | Label | Section | Category | Sensitivity | Type |","|---------|-------|---------|----------|------------|------|") + $rows + '<!-- SCHEMA-SUMMARY:END -->'
          $content = Get-Content $mdPath -Raw
          if($content -match '<!-- SCHEMA-SUMMARY:START -->[\s\S]*?<!-- SCHEMA-SUMMARY:END -->'){
            $content = [regex]::Replace($content,'<!-- SCHEMA-SUMMARY:START -->[\s\S]*?<!-- SCHEMA-SUMMARY:END -->',$table -join "`n")
          } else {
            $content += "`n$table" -join "`n"
          }
          Set-Content $mdPath -Value $content -Encoding UTF8
          git add $mdPath; git commit -m 'docs(schema): refresh schema summary table' | Out-Null
      - name: FIELD_SCHEMA last updated timestamp
        shell: pwsh
        run: |
          $mdPath = 'docs/FIELD_SCHEMA.md'
          if(Test-Path $mdPath){
            $c = Get-Content $mdPath -Raw
            $stamp = (Get-Date).ToUniversalTime().ToString('yyyy-MM-dd')
            if($c -match '_Last updated:'){ $nc = [regex]::Replace($c,'_Last updated: .*','_Last updated: '+$stamp) } else { $nc = $c + "`n_Last updated: $stamp" }
            if($nc -ne $c){ Set-Content $mdPath -Value $nc -Encoding UTF8; git add $mdPath; git commit -m 'docs(schema): update timestamp' | Out-Null }
          }
      - name: Generate DOC_INDEX
        shell: pwsh
        run: |
          $files = Get-ChildItem docs -Filter *.md | Sort-Object Name
          $lines = @('# Documentation Index','','| File | Last Modified (UTC) |','|------|-------------------|')
          foreach($f in $files){ $dt = (Get-Date $f.LastWriteTimeUtc -Format 'yyyy-MM-dd'); $lines += "| $($f.Name) | $dt |" }
          $out = $lines -join "`n"
          Set-Content docs/DOC_INDEX.md -Value $out -Encoding UTF8
          git add docs/DOC_INDEX.md; git commit -m 'docs: regenerate DOC_INDEX' | Out-Null
      - name: Generate Markdown TOCs
        shell: pwsh
        run: |
          function Get-Slug($text){
            $slug = $text.ToLower() -replace "[^a-z0-9\s-]","" -replace "\s+","-" -replace "-+","-"
            return $slug.Trim('-')
          }
          $mdFiles = Get-ChildItem -Recurse -File -Include *.md
          foreach($file in $mdFiles){
            $raw = Get-Content $file.FullName -Raw
            if($raw -notmatch '<!-- TOC:START -->'){ continue }
            $lines = $raw -split "`n"
            $headings = @()
            foreach($l in $lines){
              if($l -match '^(#{2,6})\s+(.+)$'){  # skip H1
                $level = $Matches[1].Length
                $text = $Matches[2].Trim()
                $slug = Get-Slug $text
                $indent = '  ' * ($level - 2)  # H2 no indent
                $headings += "$indent- [$text](#$slug)"
              }
            }
            $tocBlock = "<!-- TOC:START -->`n<!-- (Generated automatically – do not edit manually) -->`n" + ($headings -join "`n") + "`n<!-- TOC:END -->"
            $updated = [regex]::Replace($raw,'<!-- TOC:START -->[\s\S]*?<!-- TOC:END -->',$tocBlock)
            if($updated -ne $raw){ Set-Content $file.FullName -Value $updated -Encoding UTF8; git add $file.FullName }
          }
          git diff --cached --quiet || git commit -m 'docs(toc): update generated TOCs' | Out-Null
      - name: CONTRIBUTORS generation
        shell: pwsh
        run: |
          $contributors = git shortlog -sne | ForEach-Object { $_ -replace '\t',' ' }
          $content = "# Contributors`n`n| Commits | Author | Email |`n|---------|--------|-------|`n" + ($contributors | ForEach-Object { $p = $_ -split ' '; $count=$p[0]; $rest=$p[1..($p.Length-1)] -join ' '; if($rest -match '<(.+?)>'){ $name = $rest -replace '<.*?>',''; $email = $Matches[1] } else { $name=$rest; $email='' }; "| $count | $name | $email |" }) -join "`n"
          Set-Content CONTRIBUTORS.md -Value $content -Encoding UTF8
          git add CONTRIBUTORS.md; git commit -m 'docs: update CONTRIBUTORS' | Out-Null
      - name: Release notes preview (PR only)
        if: github.event_name == 'pull_request'
        shell: pwsh
        run: |
          $lastTag = (git tag --list 'v*' --sort=-creatordate | Select-Object -First 1)
            if([string]::IsNullOrWhiteSpace($lastTag)){ $range = (git rev-list --max-parents=0 HEAD) + '..HEAD' } else { $range = "$lastTag..HEAD" }
          $lines = git log --pretty=%s $range
          $added = @(); $changed=@(); $fixed=@()
          foreach($l in $lines){
            if($l -like 'feat*'){ $added += $l.Substring($l.IndexOf(':')+1).Trim() }
            elseif($l -like 'fix*'){ $fixed += $l.Substring($l.IndexOf(':')+1).Trim() }
            elseif($l -match '^(refactor|perf|chore|build|ci|security|docs)'){ $changed += ($l -replace '^[^:]+:','').Trim() }
          }
          if(-not $added){ $added = @('(none)') }
          if(-not $changed){ $changed = @('(none)') }
          if(-not $fixed){ $fixed = @('(none)') }
          $preview = "## Release Notes Preview (unreleased)\n### Added\n" + ($added | ForEach-Object { "- $_" }) -join "`n"
          $preview += "`n### Changed`n" + (($changed | ForEach-Object { "- $_" }) -join "`n")
          $preview += "`n### Fixed`n" + (($fixed | ForEach-Object { "- $_" }) -join "`n") + "`n"
          if(!(Test-Path metrics)){ New-Item metrics -ItemType Directory | Out-Null }
          Set-Content metrics/release-notes-preview.md -Value $preview -Encoding UTF8
          git add metrics/release-notes-preview.md; git commit -m 'docs(changelog): update release notes preview' | Out-Null
      - name: Metrics history append
        shell: pwsh
        run: |
          $manifestPath = 'metrics/build-manifest.json'
          if(!(Test-Path $manifestPath)){ Write-Host 'No build-manifest.json yet (earlier step may not have produced)'; exit 0 }
          $json = Get-Content $manifestPath -Raw
          $history = 'metrics/build-history.jsonl'
          if(!(Test-Path $history)){ New-Item -ItemType File -Path $history | Out-Null }
          # Avoid duplicate commit entries
          $commit = (ConvertFrom-Json $json).commit
          $already = Select-String -Path $history -Pattern '"commit"\s*:\s*"'+[regex]::Escape($commit)+'"' -SimpleMatch -Quiet
          if(-not $already){ Add-Content $history $json; git add $history; git commit -m "chore(metrics): append build history $commit" | Out-Null } else { Write-Host 'Commit already recorded in history' }
      - name: Security heuristic tuning
        shell: pwsh
        run: |
          # Re-run heuristic with whitelist filtering for names and addresses
          $whitelistNames = @('Veteran Affairs','Health System','Admission Flow')
          $whitelistPatterns = $whitelistNames | ForEach-Object { [regex]::Escape($_) }
          $joined = ($whitelistPatterns -join '|')
          $warn = @()
          $files = git ls-files | Where-Object { $_ -notlike 'tests/flowSuccess/*' -and $_ -notlike 'tests/flowFailure/*' }
          foreach($f in $files){
            $text = Get-Content $f -Raw
            $phones = [regex]::Matches($text,'\b\d{3}[ -]?\d{3}[ -]?\d{4}\b') | ForEach-Object { $_.Value } | Where-Object { $_ -notmatch '[Xx\*]{3}-?[Xx\*]{2}-?[Xx\*]{4}' }
            foreach($p in $phones){ $warn += "$f: phone?$p" }
            $addr = [regex]::Matches($text,'\b\d{1,5}\s+[A-Z][a-zA-Z]+\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd)\b') | ForEach-Object { $_.Value }
            foreach($a in $addr){ if($joined -and $a -match $joined){ continue }; $warn += "$f: address?$a" }
            $names = [regex]::Matches($text,'\b[A-Z][a-z]+\s+[A-Z][a-z]+\b') | ForEach-Object { $_.Value } | Where-Object { $_ -notmatch 'Veteran|Not Provided' }
            foreach($n in $names){ if($joined -and $n -match $joined){ continue }; $warn += "$f: name?$n" }
          }
          if($warn.Count -gt 0){ Write-Warning "Heuristic PHI candidates (filtered):`n$($warn -join "`n")" } else { Write-Host 'No heuristic PHI candidates after filtering' }
      - name: Artifact table regeneration
        shell: pwsh
        run: |
          $manifest = 'config/artifacts.manifest.json'
          if(!(Test-Path $manifest)){ Write-Host 'Artifact manifest missing'; exit 0 }
          $data = Get-Content $manifest -Raw | ConvertFrom-Json
          $rows = foreach($a in $data.artifacts){ "| `$($a.file)` | `$($a.location)` | $($a.purpose) |" }
          $table = @('| File | Location | Purpose |','|------|----------|---------|') + $rows
          $readme = Get-Content README.md -Raw
          if($readme -notmatch '<!-- ARTIFACT-TABLE:START -->'){ Write-Host 'No artifact table markers'; exit 0 }
          $newBlock = '<!-- ARTIFACT-TABLE:START -->' + "`n" + ($table -join "`n") + "`n" + '<!-- ARTIFACT-TABLE:END -->'
          $updated = [regex]::Replace($readme,'<!-- ARTIFACT-TABLE:START -->[\s\S]*?<!-- ARTIFACT-TABLE:END -->',$newBlock)
          if($updated -ne $readme){ Set-Content README.md -Value $updated -Encoding UTF8; git add README.md; git commit -m 'docs(readme): regenerate artifact table' | Out-Null } else { Write-Host 'Artifact table already current' }
      - name: Large PR warning
        if: github.event_name == 'pull_request'
        shell: pwsh
        run: |
          $count = (git diff --name-only origin/main...HEAD | Measure-Object).Count
          if($count -gt 30){ Write-Warning "Large PR: $count files changed" } else { Write-Host "PR size OK ($count files)" }
      - name: PR summary comment
        if: github.event_name == 'pull_request'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $schemaCount = (Get-Content config/fieldSchema.json -Raw | ConvertFrom-Json).fields.Count
          $fileCount = (git diff --name-only origin/main...HEAD | Measure-Object).Count
          $sha = (git rev-parse --short HEAD)
          $body = "PR Metrics:\n- Files Changed: $fileCount\n- Schema Fields Now: $schemaCount\n- Head: $sha"
          $pr = $env:GITHUB_REF -replace 'refs/pull/','' -replace '/merge',''
          $url = "https://api.github.com/repos/${env:GITHUB_REPOSITORY}/issues/$pr/comments"
          Invoke-RestMethod -Method Post -Uri $url -Headers @{Authorization="Bearer $env:GITHUB_TOKEN"} -Body (@{body=$body} | ConvertTo-Json)
      - name: Push badge update (if any)
        if: always()
        run: |
          git push origin HEAD:main || echo 'No badge changes to push'
      - name: Check README quickstart present
        shell: pwsh
        run: |
          $readme = Get-Content README.md -Raw
          if($readme -notmatch 'Quickstart'){ Write-Error 'Quickstart section missing in README'; exit 1 }
          Write-Host 'README quickstart found'
      - name: Verify CHANGELOG Unreleased section
        shell: pwsh
        run: |
          $cl = Get-Content CHANGELOG.md -Raw
          if($cl -notmatch '## \[Unreleased\]'){ Write-Error 'Missing Unreleased section in CHANGELOG'; exit 1 }
          Write-Host 'CHANGELOG Unreleased section present'
      - name: Basic link lint (README)
        shell: pwsh
        run: |
          $readme = Get-Content README.md -Raw
          $links = Select-String -InputObject $readme -Pattern '\[(.+?)\]\((.+?)\)' | ForEach-Object { $_.Matches } | ForEach-Object { $_.Groups[2].Value }
          $fails = @()
          foreach($l in $links){
            if($l -match '^(http|https)://'){ try { (Invoke-WebRequest -Uri $l -UseBasicParsing -Method Head -TimeoutSec 10) | Out-Null } catch { $fails += $l } }
          }
          if($fails.Count -gt 0){ Write-Warning "Broken links:`n$($fails -join "`n")" }
          Write-Host 'Link lint complete'
