name: CI Audit
on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  audit:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up git for automated commit
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
      - name: Validate fieldSchema.json
        shell: pwsh
        run: |
          $schemaPath = 'config/fieldSchema.json'
          if(!(Test-Path $schemaPath)){ Write-Error 'fieldSchema.json missing'; exit 1 }
          $json = Get-Content $schemaPath -Raw | ConvertFrom-Json
          if(-not $json.fields){ Write-Error 'No fields array found'; exit 1 }
          $invalid = @()
          foreach($f in $json.fields){
            if([string]::IsNullOrWhiteSpace($f.internalName)){ $invalid += 'missing internalName' }
            if([string]::IsNullOrWhiteSpace($f.fallback)){ $invalid += "$($f.internalName): missing fallback" }
            if($f.choice -and -not $f.requiresValueSuffix){ $invalid += "$($f.internalName): choice without requiresValueSuffix" }
          }
          if($invalid.Count -gt 0){ Write-Error ("Schema validation errors:`n" + ($invalid -join "`n")); exit 1 }
          Write-Host 'fieldSchema.json validation OK'
      - name: Auto-update README badge schema field count
        shell: pwsh
        run: |
          $schemaPath = 'config/fieldSchema.json'
          $readmePath = 'README.md'
          if(!(Test-Path $schemaPath)){ Write-Error 'Schema file missing for badge update'; exit 1 }
          if(!(Test-Path $readmePath)){ Write-Error 'README.md missing'; exit 1 }
          $schemaJson = Get-Content $schemaPath -Raw | ConvertFrom-Json
          if(-not $schemaJson.fields){ Write-Error 'fields array absent in schema'; exit 1 }
          $count = $schemaJson.fields.Count
          $readme = Get-Content $readmePath -Raw
          $markerPattern = '(?s)<!-- BADGES:START -->(.*?)<!-- BADGES:END -->'
          $m = [regex]::Match($readme, $markerPattern)
          if(-not $m.Success){ Write-Error 'Badge markers not found'; exit 1 }
          $block = $m.Value
          $countMatch = [regex]::Match($block, 'Schema Fields:\s*(\d+)')
          if(-not $countMatch.Success){ Write-Error 'Schema Fields count token missing in badge block'; exit 1 }
          $existing = [int]$countMatch.Groups[1].Value
          if($existing -eq $count){ Write-Host "Badge already up-to-date ($count)."; exit 0 }
          $newBlock = $block -replace 'Schema Fields:\s*\d+', "Schema Fields: $count"
          $updated = $readme.Substring(0,$m.Index) + $newBlock + $readme.Substring($m.Index + $m.Length)
          Set-Content -Path $readmePath -Value $updated -Encoding UTF8
          git add $readmePath
          git commit -m "chore(readme): update schema fields badge to $count" || echo 'No changes to commit'
      - name: Update build info block
        shell: pwsh
        run: |
          $readmePath = 'README.md'
          if(!(Test-Path $readmePath)){ Write-Error 'README.md missing'; exit 1 }
          $content = Get-Content $readmePath -Raw
          if($content -notmatch '<!-- BUILDINFO:START -->'){ Write-Error 'Build info markers missing'; exit 1 }
          $shortSha = (git rev-parse --short HEAD).Trim()
          $utcDate = (Get-Date).ToUniversalTime().ToString('yyyy-MM-dd')
          $schemaPath = 'config/fieldSchema.json'
          $schemaCount = if(Test-Path $schemaPath){ (Get-Content $schemaPath -Raw | ConvertFrom-Json).fields.Count } else { 0 }
          # Determine last semantic tag
          $lastTag = (git tag --list 'v*' --sort=-creatordate | Select-Object -First 1)
          if([string]::IsNullOrWhiteSpace($lastTag)){ $lastTag = 'none' }
          if($lastTag -eq 'none'){
            $commitsSince = (git rev-list --count HEAD)
            # Files since 'none' treated as total tracked files for initial baseline
            $filesSince = (git ls-files | Measure-Object | ForEach-Object { $_.Count })
          } else {
            $commitsSince = (git rev-list --count "$lastTag..HEAD")
            $filesSince = (git diff --name-only $lastTag HEAD | Measure-Object | ForEach-Object { $_.Count })
          }
          if(-not $filesSince){ $filesSince = 0 }
          $newBlock = "<!-- BUILDINFO:START --><div><em>Build Info</em>: Commit <code>$shortSha</code> • UTC <code>$utcDate</code> • Last Tag <code>$lastTag</code> • Commits Since Tag <code>$commitsSince</code> • Files Since Tag <code>$filesSince</code> • Schema Fields Snapshot <code>$schemaCount</code></div><!-- BUILDINFO:END -->"
          $updated = [regex]::Replace($content,'<!-- BUILDINFO:START -->.*?<!-- BUILDINFO:END -->',$newBlock,'Singleline')
          if($updated -ne $content){ Set-Content -Path $readmePath -Value $updated -Encoding UTF8; git add $readmePath; git commit -m "chore(readme): refresh build info ($shortSha)" | Out-Null } else { Write-Host 'Build info already current' }
      - name: Push badge update (if any)
        if: always()
        run: |
          git push origin HEAD:main || echo 'No badge changes to push'
      - name: Check README quickstart present
        shell: pwsh
        run: |
          $readme = Get-Content README.md -Raw
          if($readme -notmatch 'Quickstart'){ Write-Error 'Quickstart section missing in README'; exit 1 }
          Write-Host 'README quickstart found'
      - name: Verify CHANGELOG Unreleased section
        shell: pwsh
        run: |
          $cl = Get-Content CHANGELOG.md -Raw
          if($cl -notmatch '## \[Unreleased\]'){ Write-Error 'Missing Unreleased section in CHANGELOG'; exit 1 }
          Write-Host 'CHANGELOG Unreleased section present'
      - name: Basic link lint (README)
        shell: pwsh
        run: |
          $readme = Get-Content README.md -Raw
          $links = Select-String -InputObject $readme -Pattern '\[(.+?)\]\((.+?)\)' | ForEach-Object { $_.Matches } | ForEach-Object { $_.Groups[2].Value }
          $fails = @()
          foreach($l in $links){
            if($l -match '^(http|https)://'){ try { (Invoke-WebRequest -Uri $l -UseBasicParsing -Method Head -TimeoutSec 10) | Out-Null } catch { $fails += $l } }
          }
          if($fails.Count -gt 0){ Write-Warning "Broken links:`n$($fails -join "`n")" }
          Write-Host 'Link lint complete'
