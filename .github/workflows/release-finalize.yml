name: Release Finalization
on:
  push:
    tags:
      - 'v*'

jobs:
  finalize:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set git identity
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
      - name: Gather metrics & update badges and velocity log
        run: |
          set -euo pipefail
          TAG_REF="${GITHUB_REF##*/}"
          if [[ ! $TAG_REF =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9.-]+)?$ ]]; then echo "Tag $TAG_REF not semver"; exit 1; fi
          echo "Processing tag: $TAG_REF"
          if [ ! -f config/fieldSchema.json ]; then echo "Missing config/fieldSchema.json"; exit 1; fi
          SCHEMA_COUNT=$(jq '.fields | length' config/fieldSchema.json)
          echo "Schema fields: $SCHEMA_COUNT"
          PREV_TAG=$(git tag --list 'v*' --sort=-creatordate | grep -v "$TAG_REF" | tail -n1 || true)
          if [ -z "$PREV_TAG" ]; then BASE=$(git rev-list --max-parents=0 HEAD); FILE_COUNT=$(git diff --name-only $BASE $TAG_REF | wc -l); else FILE_COUNT=$(git diff --name-only $PREV_TAG $TAG_REF | wc -l); fi
          echo "Files changed since previous tag: $FILE_COUNT"
          if [ -z "$PREV_TAG" ]; then NEW_FIELDS_DELTA=$SCHEMA_COUNT; else PREV_FIELDS=$(git show $PREV_TAG:config/fieldSchema.json 2>/dev/null | jq '.fields | length'); NEW_FIELDS_DELTA=$((SCHEMA_COUNT-PREV_FIELDS)); fi
          TOTAL_FILES=$(git ls-files | wc -l)
          if [ "$TOTAL_FILES" -gt 0 ]; then CHANGE_DENSITY=$(awk -v f=$FILE_COUNT -v t=$TOTAL_FILES 'BEGIN{ printf "%.2f", (t==0?0:(f/t*100)) }'); else CHANGE_DENSITY=0; fi
          if [ -n "$PREV_TAG" ]; then PREV_DATE=$(git log -1 --format=%cI $PREV_TAG); NOW_DATE=$(date -u +%s); PREV_SECS=$(date -u -d "$PREV_DATE" +%s); DAYS_SINCE=$(( (NOW_DATE-PREV_SECS)/86400 )); else DAYS_SINCE='N/A'; fi
          echo "New fields delta: $NEW_FIELDS_DELTA"; echo "Change density: $CHANGE_DENSITY%"; echo "Days since previous tag: $DAYS_SINCE"
          DATE_UTC=$(date -u +%Y-%m-%d)
          if [ ! -f README.md ]; then echo "README.md missing"; exit 1; fi
          if ! grep -q '<!-- BADGES:START -->' README.md; then echo "Badge markers missing"; exit 1; fi
          EXISTING_COUNT=$(grep -Eo 'Schema Fields: [0-9]+' README.md | head -n1 | awk '{print $3}') || true
          if [ "$EXISTING_COUNT" != "$SCHEMA_COUNT" ]; then sed -i -E "/BADGES:START/,/BADGES:END/ s/Schema Fields: [0-9]+/Schema Fields: $SCHEMA_COUNT/" README.md; echo "Updated inline badge: $EXISTING_COUNT -> $SCHEMA_COUNT"; else echo "Inline badge already $SCHEMA_COUNT"; fi
          mkdir -p assets/badges
          # Dynamic badge color scaling based on external thresholds config if present
          if [ -f config/badgeThresholds.json ]; then
            GREEN_MAX=$(jq -r '.greenMax' config/badgeThresholds.json)
            YELLOW_MAX=$(jq -r '.yellowMax' config/badgeThresholds.json)
            ORANGE_MAX=$(jq -r '.orangeMax' config/badgeThresholds.json)
            if [ "$SCHEMA_COUNT" -le "$GREEN_MAX" ]; then BADGE_COLOR="#4c1";
            elif [ "$SCHEMA_COUNT" -le "$YELLOW_MAX" ]; then BADGE_COLOR="#dfb317";
            elif [ "$SCHEMA_COUNT" -le "$ORANGE_MAX" ]; then BADGE_COLOR="#fe7d37";
            else BADGE_COLOR="#e05d44"; fi
          else
            if [ "$SCHEMA_COUNT" -le 10 ]; then BADGE_COLOR="#4c1"; elif [ "$SCHEMA_COUNT" -le 20 ]; then BADGE_COLOR="#dfb317"; elif [ "$SCHEMA_COUNT" -le 30 ]; then BADGE_COLOR="#fe7d37"; else BADGE_COLOR="#e05d44"; fi
          fi
          # Adjust right segment width for multi-digit counts (base 55, +6 per extra digit beyond 2)
          COUNT_LEN=${#SCHEMA_COUNT}
          RIGHT_W=$((55 + (COUNT_LEN>2?(COUNT_LEN-2)*6:0)))
          TOTAL_W=$((85 + RIGHT_W))
          if [ $TOTAL_W -lt 140 ]; then TOTAL_W=140; fi
          printf '%s\n' "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"$TOTAL_W\" height=\"20\" role=\"img\" aria-label=\"schema fields: $SCHEMA_COUNT\">" \
            "  <linearGradient id=\"g\" x2=\"0\" y2=\"100%\"><stop offset=\"0\" stop-color=\"#bbb\" stop-opacity=\".1\"/><stop offset=\"1\" stop-opacity=\".1\"/></linearGradient>" \
            "  <rect rx=\"3\" width=\"$TOTAL_W\" height=\"20\" fill=\"#555\"/>" \
            "  <rect rx=\"3\" x=\"85\" width=\"$RIGHT_W\" height=\"20\" fill=\"$BADGE_COLOR\"/>" \
            "  <path fill=\"$BADGE_COLOR\" d=\"M85 0h4v20h-4z\"/>" \
            "  <rect rx=\"3\" width=\"$TOTAL_W\" height=\"20\" fill=\"url(#g)\"/>" \
            "  <g fill=\"#fff\" text-anchor=\"middle\" font-family=\"Verdana,Geneva,DejaVu Sans,sans-serif\" font-size=\"11\">" \
            "    <text x=\"43\" y=\"14\">schema fields</text>" \
            "    <text x=\"$((85 + RIGHT_W/2))\" y=\"14\">$SCHEMA_COUNT</text>" \
            "  </g>" \
            "</svg>" > assets/badges/schema-field-count.svg
          echo "SVG badge regenerated (color=$BADGE_COLOR width=$TOTAL_W)"
          LOG_PATH="docs/CHANGE_VELOCITY_LOG.md"
          if [ ! -f "$LOG_PATH" ]; then echo "Missing $LOG_PATH"; exit 1; fi
          if grep -q "| $TAG_REF |" "$LOG_PATH"; then echo "Velocity row exists"; else echo "| $DATE_UTC | $TAG_REF | $FILE_COUNT | $SCHEMA_COUNT | +$NEW_FIELDS_DELTA fields |" >> "$LOG_PATH"; echo "Velocity log appended"; fi
          # Build velocity trend table & sparkline (last up to 10 releases)
          RECENT_ROWS=$(grep '^|' "$LOG_PATH" | grep -v 'Date' | tail -n 10)
          RECENT_COUNTS=$(echo "$RECENT_ROWS" | awk -F'|' '{print $4}' | tr -d ' ')
          MIN=$(echo "$RECENT_COUNTS" | tr ' ' '\n' | sort -n | head -n1)
          MAX=$(echo "$RECENT_COUNTS" | tr ' ' '\n' | sort -n | tail -n1)
          SPARK=''
          for v in $RECENT_COUNTS; do
            if [ "$MAX" = "$MIN" ]; then idx=0; else
              norm=$(awk -v val=$v -v min=$MIN -v max=$MAX 'BEGIN{ if(max-min==0){print 0}else{print (val-min)/(max-min)} }')
              idx=$(awk -v n=$norm 'BEGIN{ printf "%d", (n*7) }')
            fi
            case $idx in
              0) ch='▁';; 1) ch='▂';; 2) ch='▃';; 3) ch='▄';; 4) ch='▅';; 5) ch='▆';; 6) ch='▇';; 7) ch='█';; *) ch='▁';; esac
            SPARK="$SPARK$ch"
          done
          TABLE_HEADER='| Date | Tag | Files | Fields | Delta | Density % | Days Since Prev |'
          TABLE_SEP='|------|-----|-------|--------|-------|-----------|-----------------|'
          TABLE_ROWS=$(echo "$RECENT_ROWS" | awk -F'|' -v dens=$CHANGE_DENSITY -v days=$DAYS_SINCE -v prev=$PREV_TAG -v tag=$TAG_REF 'BEGIN{OFS="|"} {gsub(/^[ \t]+|[ \t]+$/,"",$2); if(NR>0){print "|" $2 "|" $3 "|" $4 "|" $5 "|" $6 "|" dens "|" days "|"}}')
          # Insert / replace trend block between markers (create if absent)
          if grep -q '<!-- VELOCITY-TREND:START -->' "$LOG_PATH"; then
            sed -i "/VELOCITY-TREND:START/,/VELOCITY-TREND:END/c\\<!-- VELOCITY-TREND:START -->\nFIELD COUNT SPARKLINE: $SPARK (min=$MIN max=$MAX)\n$TABLE_HEADER\n$TABLE_SEP\n$TABLE_ROWS\n<!-- VELOCITY-TREND:END -->" "$LOG_PATH"
          else
            printf '\n<!-- VELOCITY-TREND:START -->\nFIELD COUNT SPARKLINE: %s (min=%s max=%s)\n%s\n%s\n%s\n<!-- VELOCITY-TREND:END -->\n' "$SPARK" "$MIN" "$MAX" "$TABLE_HEADER" "$TABLE_SEP" "$TABLE_ROWS" >> "$LOG_PATH"
          fi
          # Generate build metrics JSON artifact (commit snapshot)
          mkdir -p metrics
          printf '{\n  "tag": "%s",\n  "dateUtc": "%s",\n  "schemaFieldCount": %s,\n  "newFieldsDelta": %s,\n  "filesChanged": %s,\n  "changeDensityPercent": "%s",\n  "daysSincePreviousTag": "%s",\n  "previousTag": "%s"\n}\n' \
            "$TAG_REF" "$DATE_UTC" "$SCHEMA_COUNT" "$NEW_FIELDS_DELTA" "$FILE_COUNT" "$CHANGE_DENSITY" "$DAYS_SINCE" "${PREV_TAG:-none}" > metrics/build-manifest.json
          git add metrics/build-manifest.json
          if git diff --quiet; then echo "No changes to commit"; else git add README.md assets/badges/schema-field-count.svg "$LOG_PATH"; git commit -m "chore(release-metrics): snapshot $TAG_REF (schema=$SCHEMA_COUNT files=$FILE_COUNT)"; fi
      - name: Generate release notes & finalize CHANGELOG
        run: |
          set -euo pipefail
          TAG_REF="${GITHUB_REF##*/}"
          DATE_UTC=$(date -u +%Y-%m-%d)
          if [ ! -f CHANGELOG.md ]; then echo "CHANGELOG.md missing"; exit 1; fi
          PREV_TAG=$(git tag --list 'v*' --sort=-creatordate | grep -v "$TAG_REF" | head -n1 || true)
          COMMITS_RANGE=""
          if [ -n "$PREV_TAG" ]; then COMMITS_RANGE="$PREV_TAG..$TAG_REF"; else COMMITS_RANGE="$(git rev-list --max-parents=0 HEAD)..$TAG_REF"; fi
          echo "Collecting conventional commits in range: $COMMITS_RANGE"
          RAW_COMMITS=$(git log --pretty='%s' $COMMITS_RANGE || true)
          ADDED_LIST=""; CHANGED_LIST=""; FIXED_LIST=""
          while IFS= read -r line; do
            case "$line" in
              feat* ) ADDED_LIST+="- ${line#feat*:}\n" ;;
              fix* ) FIXED_LIST+="- ${line#fix*:}\n" ;;
              refactor*|perf*|chore*|build*|ci*|security* ) CHANGED_LIST+="- ${line#*:}\n" ;;
              docs* ) CHANGED_LIST+="- (docs) ${line#docs*:}\n" ;;
              * ) : ;;
            esac
          done <<< "$RAW_COMMITS"
          [ -z "$ADDED_LIST" ] && ADDED_LIST="- (none)\n"
          [ -z "$CHANGED_LIST" ] && CHANGED_LIST="- (none)\n"
          [ -z "$FIXED_LIST" ] && FIXED_LIST="- (none)\n"
          CHANGELOG_CONTENT=$(cat CHANGELOG.md)
          # Extract Unreleased block if present
          if echo "$CHANGELOG_CONTENT" | grep -q '## \[Unreleased\]'; then
            UNRELEASED_BLOCK=$(echo "$CHANGELOG_CONTENT" | awk '/## \[Unreleased\]/{flag=1;next}/## \[/{flag=0}flag')
          else
            UNRELEASED_BLOCK=""
          fi
          NEW_VERSION_SECTION="## [$TAG_REF] - $DATE_UTC\n### Added\n$ADDED_LIST\n### Changed\n$CHANGED_LIST\n### Fixed\n$FIXED_LIST\n"
          # Insert new version section above previous versions (after Unreleased)
          if echo "$CHANGELOG_CONTENT" | grep -q "## \[$TAG_REF\]"; then echo "CHANGELOG already contains $TAG_REF"; else
            if echo "$CHANGELOG_CONTENT" | grep -q '## \[Unreleased\]'; then
              # Rebuild file: header + Unreleased skeleton + new version + rest
              HEADER_PART=$(echo "$CHANGELOG_CONTENT" | awk '1;/## \[Unreleased\]/ {exit}')
              REST_PART=$(echo "$CHANGELOG_CONTENT" | awk 'f;/## \[0/{f=1}' )
              UNRELEASED_SKELETON='## [Unreleased]\n### Added\n- (placeholder)\n### Changed\n- (placeholder)\n### Fixed\n- (placeholder)\n'
              printf '%s\n%s\n%s\n%s\n' "$HEADER_PART" "$UNRELEASED_SKELETON" "$NEW_VERSION_SECTION" "$REST_PART" > CHANGELOG.md
            else
              printf '%s\n%s\n' "$CHANGELOG_CONTENT" "$NEW_VERSION_SECTION" > CHANGELOG.md
            fi
            git add CHANGELOG.md
            git commit -m "docs(changelog): finalize release notes for $TAG_REF" || echo "No CHANGELOG changes"
          fi
          # Write release notes artifact
          mkdir -p metrics
          printf 'Release: %s\nDate: %s\n\nAdded:\n%s\nChanged:\n%s\nFixed:\n%s\n' "$TAG_REF" "$DATE_UTC" "$ADDED_LIST" "$CHANGED_LIST" "$FIXED_LIST" > metrics/release-notes-$TAG_REF.md
          git add metrics/release-notes-$TAG_REF.md
          git commit -m "chore(release-notes): add notes for $TAG_REF" || echo "No release notes changes"
      - name: Push changes
        run: |
          git push origin HEAD:main || echo "No metric changes to push"
